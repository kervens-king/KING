/* 
 * Copyright ¬© 2025 Mirage
 * Ce fichier fait partie de Kord et est sous licence GNU GPLv3.
 * Et j'esp√®re que vous savez ce que vous faites ici.
 * Vous ne pouvez pas utiliser ce fichier sauf en conformit√© avec la Licence.
 * Voir le fichier LICENSE ou https://www.gnu.org/licenses/gpl-3.0.html
 * -------------------------------------------------------------------------------
 */

const { King, commands, wtype, prefix, getData, storeData, changeFont, formatTime, config } = require("../core/")
const path = require("path")
const fs = require("fs")

class GestionnaireCommandes {
  constructor() {
    this.pre = prefix
    this.initialiserDonnees()
  }

  async initialiserDonnees() {
    // Initialisation des donn√©es par d√©faut
    const areactParDefaut = {
      active: false,
      global: false,
      activeChats: []
    }
    
    if (!await getData("areact_config")) {
      await storeData("areact_config", JSON.stringify(areactParDefaut, null, 2))
    }
  }

  // M√©thodes utilitaires
  async obtenirDonneesStickers() {
    try {
      const data = await getData("stk_cmd")
      return data || {}
    } catch (error) {
      console.error("Erreur donn√©es stickers:", error)
      return {}
    }
  }

  async sauvegarderDonneesStickers(donnees) {
    try {
      await storeData("stk_cmd", JSON.stringify(donnees, null, 2))
      return true
    } catch (error) {
      console.error("Erreur sauvegarde stickers:", error)
      return false
    }
  }
}

const gestionnaire = new GestionnaireCommandes()

// ==================== COMMANDES AUTOCCOLLANTS ====================

King({
  cmd: "setcmd",
  desc: "üîó Lier une commande √† un autocollant",
  fromMe: true,
  type: "tools",
  category: "autocollants"
}, async (m, text) => {
  try {
    if (!m.quoted?.sticker) {
      return await m.send(`üé¥ *R√©pondez √† un autocollant* \n_Format : ${prefix}setcmd [commande]_ \n_Exemple : ${prefix}setcmd ping_`)
    }
    
    if (!text) {
      return await m.send(`‚ùå *Commande manquante* \n_Sp√©cifiez la commande √† lier_`)
    }
    
    const commande = text.trim().split(/\s+/)[0]
    const hash = m.quoted.fileSha256 ? Buffer.from(m.quoted.fileSha256).toString('hex') : null
    
    if (!hash) {
      return await m.send("‚ùå *Hash introuvable* \n_Impossible d'identifier l'autocollant_")
    }
    
    const stk_cmd = await gestionnaire.obtenirDonneesStickers()
    stk_cmd[hash] = text
    
    if (await gestionnaire.sauvegarderDonneesStickers(stk_cmd)) {
      return await m.send(`‚úÖ *Autocollant li√© !* \nüìå Commande : *${commande}* \nüîó Hash : \`${hash.slice(0, 12)}...\``)
    } else {
      return await m.send("‚ùå *Erreur sauvegarde* \n_Impossible de sauvegarder la liaison_")
    }
  } catch (e) {
    console.error("‚ùå Erreur setcmd:", e)
    return await m.sendErr(e)
  }
})

King({
  cmd: "delcmd",
  desc: "üóëÔ∏è Supprimer une liaison d'autocollant",
  fromMe: true,
  type: "tools",
  category: "autocollants"
}, async (m) => {
  try {
    if (!m.quoted?.sticker) {
      return await m.send(`üé¥ *R√©pondez √† un autocollant* \n_Pour supprimer sa commande li√©e_`)
    }
    
    const hash = m.quoted.fileSha256 ? Buffer.from(m.quoted.fileSha256).toString("hex") : null
    if (!hash) return await m.send("‚ùå *Hash introuvable*")
    
    const stk_cmd = await gestionnaire.obtenirDonneesStickers()
    
    if (!stk_cmd[hash]) {
      return await m.send("‚ùå *Aucune commande* \n_Cet autocollant n'a pas de commande li√©e_")
    }
    
    const ancienneCommande = stk_cmd[hash]
    delete stk_cmd[hash]
    
    if (await gestionnaire.sauvegarderDonneesStickers(stk_cmd)) {
      return await m.send(`‚úÖ *Commande supprim√©e !* \nüóëÔ∏è Ancienne : *${ancienneCommande}*`)
    }
  } catch (e) {
    console.error("‚ùå Erreur delcmd:", e)
    return await m.sendErr(e)
  }
})

King({
  cmd: "listcmd|listcmds",
  desc: "üìã Lister les commandes d'autocollants",
  fromMe: true,
  type: "tools",
  category: "autocollants"
}, async (m) => {
  try {
    const stk_cmd = await gestionnaire.obtenirDonneesStickers()
    const entrees = Object.entries(stk_cmd)
    
    if (entrees.length === 0) {
      return await m.send("üì≠ *Aucune liaison* \n_Aucun autocollant n'a de commande li√©e_")
    }
    
    let texte = `üìã *COMMANDES AUTOCCOLLANTS (${entrees.length})*\n\n`
    
    entrees.forEach(([hash, cmd], index) => {
      texte += `${index + 1}. *${cmd}*\n   üîó \`${hash.slice(0, 16)}...\`\n\n`
    })
    
    return await m.send(texte.trim())
  } catch (e) {
    console.error("‚ùå Erreur listcmd:", e)
    return await m.sendErr(e)
  }
})

King({
  cmd: "delallcmds",
  desc: "üí• Supprimer toutes les liaisons",
  fromMe: true,
  type: "tools",
  category: "autocollants"
}, async (m) => {
  try {
    const stk_cmd = await gestionnaire.obtenirDonneesStickers()
    const nombre = Object.keys(stk_cmd).length
    
    if (nombre === 0) {
      return await m.send("üì≠ *D√©j√† vide* \n_Aucune commande √† supprimer_")
    }
    
    if (await gestionnaire.sauvegarderDonneesStickers({})) {
      return await m.send(`üí• *Tout supprim√© !* \nüóëÔ∏è ${nombre} commande(s) effac√©e(s)`)
    }
  } catch (e) {
    console.error("‚ùå Erreur delallcmds:", e)
    return await m.sendErr(e)
  }
})

// ==================== SYST√àME DE PERMISSIONS ====================

King({
  cmd: "permit",
  desc: "üîì G√©rer les permissions de commandes",
  fromMe: true,
  type: "tools",
  category: "s√©curit√©"
}, async (m, text) => {
  try {
    const args = text.split(" ")
    const chatJid = m.chat

    if (!args[0]) {
      return await m.send(this.genererAidePermissions())
    }

    const option = args[0].toLowerCase()
    const valeur = args.slice(1).join(" ")
    let pmdata = await this.obtenirPermissions()
    
    return await this.traiterOptionPermissions(m, option, valeur, chatJid, pmdata)
  } catch (err) {
    console.error("‚ùå Erreur permit:", err)
    await m.send(`‚ùå *Erreur* \n\`\`\`${err.message}\`\`\``)
  }
})

// ==================== SYST√àME MENTION ====================

King({
  cmd: "mention",
  desc: "üëë Actions lors de la mention du propri√©taire",
  fromMe: true,
  type: "tools",
  category: "personnalisation"
}, async (m, text) => {
  try {
    let mData = await getData("mention_config") || {
      active: false,
      action: "",
      emoji: "üëë",
      text: ""
    }
    
    const args = text.split(" ")
    
    if (!args[0]) {
      return await this.afficherAideMention(m)
    }

    const option = args[0].toLowerCase()
    const valeur = args[1]
    const texteComplet = args.slice(1).join(" ")

    switch (option) {
      case "off":
        mData.active = false
        await storeData('mention_config', JSON.stringify(mData, null, 2))
        return await m.send("üîá *Mention d√©sactiv√©e* \n_Les mentions ne d√©clencheront plus d'actions_")

      case "status":
        return await this.afficherStatutMention(m)

      case "react":
        const emoji = valeur || "üëë"
        mData = { active: true, action: "react", emoji, text: "" }
        await storeData('mention_config', JSON.stringify(mData, null, 2))
        return await m.send(`‚úÖ *R√©action activ√©e* \nR√©agira avec : ${emoji}`)

      case "text":
        if (!texteComplet) return await m.send("‚ùå *Texte manquant* \n_Sp√©cifiez le message √† envoyer_")
        mData = { active: true, action: "text", emoji: "", text: texteComplet }
        await storeData('mention_config', JSON.stringify(mData, null, 2))
        return await m.send(`‚úÖ *Message configur√©* \n\"${texteComplet}\"`)

      default:
        return await this.afficherAideMention(m)
    }
  } catch (e) {
    console.error("‚ùå Erreur mention:", e)
    await m.send(`‚ùå *Erreur* \n\`\`\`${e.message}\`\`\``)
  }
})

// ==================== SYST√àME AFK ====================

class GestionnaireAFK {
  static async chargerDonnees() {
    try {
      const data = await getData("afk_config")
      return data || { users: {}, owner: { active: false, message: "", lastseen: "" } }
    } catch (err) {
      console.error("‚ùå Erreur chargement AFK:", err)
      return { users: {}, owner: { active: false, message: "", lastseen: "" } }
    }
  }

  static async sauvegarderDonnees(data) {
    try {
      await storeData("afk_config", JSON.stringify(data, null, 2))
      return true
    } catch (err) {
      console.error("‚ùå Erreur sauvegarde AFK:", err)
      return false
    }
  }
}

King({
  cmd: "afk",
  desc: "‚è∏Ô∏è Mode absent",
  fromMe: true,
  type: "tools",
  category: "utilitaire"
}, async (m, text) => {
  try {
    const messageAFK = text || "Je suis absent pour le moment"
    const afkData = await GestionnaireAFK.chargerDonnees()
    const tempsActuel = Math.round(Date.now() / 1000)

    // D√©sactivation AFK
    if (text?.toLowerCase() === "off") {
      if (m.sender === m.ownerJid) {
        afkData.owner.active = false
        await GestionnaireAFK.sauvegarderDonnees(afkData)
        return await m.send("‚úÖ *De retour !* \n_Mode AFK d√©sactiv√©_")
      } else {
        if (afkData.users[m.sender]) {
          afkData.users[m.sender].active = false
          await GestionnaireAFK.sauvegarderDonnees(afkData)
          return await m.send(`‚úÖ *Bienvenue !* \n@${m.sender.split("@")[0]} est de retour`, { mentions: [m.sender] })
        }
      }
      return await m.send("‚ùå *Non AFK* \n_Vous n'√©tiez pas en mode AFK_")
    }

    // Activation AFK
    if (m.sender === m.ownerJid) {
      afkData.owner = { active: true, message: messageAFK, lastseen: tempsActuel }
      await GestionnaireAFK.sauvegarderDonnees(afkData)
      return await m.send(`‚è∏Ô∏è *Mode AFK activ√©* \n_Message :_ ${messageAFK}`)
    } else {
      if (!afkData.users) afkData.users = {}
      afkData.users[m.sender] = { active: true, message: messageAFK, lastseen: tempsActuel }
      await GestionnaireAFK.sauvegarderDonnees(afkData)
      return await m.send(`‚è∏Ô∏è *AFK activ√©* \n@${m.sender.split("@")[0]} est maintenant AFK\n_Raison :_ ${messageAFK}`, { mentions: [m.sender] })
    }
  } catch (e) {
    console.error("‚ùå Erreur AFK:", e)
    return await m.sendErr(e)
  }
})

// ==================== R√âACTIONS AUTOMATIQUES ====================

King({
  cmd: "areact|autoreact",
  desc: "ü§ñ R√©actions automatiques",
  fromMe: true,
  type: "tools",
  category: "fun"
}, async (m, text) => {
  try {
    const args = text.split(" ")
    const option = args[0]?.toLowerCase()
    const valeur = args[1]?.toLowerCase()

    if (!option) {
      return await this.afficherAideAreact(m)
    }

    const areactData = await getData("areact_config") || { active: false, global: false, activeChats: [] }

    switch (option) {
      case "on":
        if (valeur === "global") {
          areactData.global = true
          await storeData('areact_config', JSON.stringify(areactData, null, 2))
          return await m.send("üåç *R√©actions globales activ√©es* \n_Tous les chats seront concern√©s_")
        } else {
          areactData.active = true
          if (!areactData.activeChats.includes(m.chat)) {
            areactData.activeChats.push(m.chat)
          }
          await storeData('areact_config', JSON.stringify(areactData, null, 2))
          return await m.send("‚úÖ *R√©actions activ√©es* \n_Ce chat recevra des r√©actions automatiques_")
        }

      case "off":
        if (valeur === "global") {
          areactData.global = false
          await storeData('areact_config', JSON.stringify(areactData, null, 2))
          return await m.send("üåç *R√©actions globales d√©sactiv√©es*")
        } else {
          areactData.activeChats = areactData.activeChats.filter(jid => jid !== m.chat)
          await storeData('areact_config', JSON.stringify(areactData, null, 2))
          return await m.send("‚úÖ *R√©actions d√©sactiv√©es* \n_Pour ce chat uniquement_")
        }

      case "status":
        const estActif = areactData.activeChats.includes(m.chat)
        return await m.send(
          `ü§ñ *STATUT R√âACTIONS AUTO*\n\n` +
          `üìç **Ce chat:** ${estActif ? '‚úÖ Actif' : '‚ùå Inactif'}\n` +
          `üåç **Global:** ${areactData.global ? '‚úÖ Activ√©' : '‚ùå D√©sactiv√©'}\n` +
          `üìä **Chats actifs:** ${areactData.activeChats.length}`
        )

      default:
        return await this.afficherAideAreact(m)
    }
  } catch (e) {
    console.error("‚ùå Erreur areact:", e)
    await m.send(`‚ùå *Erreur* \n\`\`\`${e.message}\`\`\``)
  }
})

// ==================== GESTION BOT ====================

King({
  cmd: "ignore",
  desc: "üö´ Ignorer ce chat",
  fromMe: true,
  type: "bot",
  category: "administration"
}, async (m) => {
  try {
    let ignores = await getData("ignored") || []
    if (!Array.isArray(ignores)) ignores = []

    if (ignores.includes(m.chat)) {
      return await m.send("‚ö†Ô∏è *D√©j√† ignor√©* \n_Ce chat est d√©j√† dans la liste d'ignor√©s_")
    }

    ignores.push(m.chat)
    await storeData("ignored", JSON.stringify(ignores, null, 2))
    return await m.send("üö´ *Chat ignor√©* \n_Le bot ne r√©pondra plus ici_")
  } catch (e) {
    console.error("‚ùå Erreur ignore:", e)
    return await m.sendErr(e)
  }
})

King({
  cmd: "allow",
  desc: "‚úÖ Autoriser ce chat",
  fromMe: true,
  type: "bot",
  category: "administration"
}, async (m) => {
  try {
    let ignores = await getData("ignored") || []
    if (!Array.isArray(ignores)) ignores = []

    if (!ignores.includes(m.chat)) {
      return await m.send("‚ÑπÔ∏è *D√©j√† autoris√©* \n_Ce chat n'est pas ignor√©_")
    }

    ignores = ignores.filter(jid => jid !== m.chat)
    await storeData("ignored", JSON.stringify(ignores, null, 2))
    return await m.send("‚úÖ *Chat autoris√©* \n_Le bot r√©pondra √† nouveau ici_")
  } catch (e) {
    console.error("‚ùå Erreur allow:", e)
    return await m.sendErr(e)
  }
})

King({
  cmd: "bot",
  desc: "‚öôÔ∏è Contr√¥le du bot",
  fromMe: true,
  type: "bot",
  category: "administration"
}, async (m, text) => {
  try {
    let ignores = await getData("ignored") || []
    const estIgnore = ignores.includes(m.chat)

    if (text?.toLowerCase() === "on") {
      if (!estIgnore) {
        return await m.send("‚úÖ *D√©j√† actif* \n_Le bot est d√©j√† activ√© ici_")
      }
      ignores = ignores.filter(jid => jid !== m.chat)
      await storeData("ignored", JSON.stringify(ignores, null, 2))
      return await m.send("üü¢ *Bot activ√©* \n_Fonctionnalit√©s restaur√©es_")
    }

    if (text?.toLowerCase() === "off") {
      if (estIgnore) {
        return await m.send("‚úÖ *D√©j√† d√©sactiv√©* \n_Le bot est d√©j√† inactif ici_")
      }
      ignores.push(m.chat)
      await storeData("ignored", JSON.stringify(ignores, null, 2))
      return await m.send("üî¥ *Bot d√©sactiv√©* \n_Le bot ne r√©pondra plus_")
    }

    return await m.send(
      `‚öôÔ∏è *CONTROLE BOT*\n\n` +
      `üü¢ \`.bot on\` - Activer le bot\n` +
      `üî¥ \`.bot off\` - D√©sactiver le bot\n` +
      `üìä Statut: ${estIgnore ? 'üî¥ D√©sactiv√©' : 'üü¢ Activ√©'}`
    )
  } catch (e) {
    console.error("‚ùå Erreur bot:", e)
    return await m.sendErr(e)
  }
})

// ==================== √âV√âNEMENTS ====================

King({ on: "all" }, async (m, text) => {
  try {
    // Gestion des mentions
    const mentionData = await getData("mention_config") || {}
    if (mentionData.active && (text?.includes(config().OWNER_NUMBER) || m.mentionedJid?.includes(m.ownerJid))) {
      if (mentionData.action === "react") {
        await m.react(mentionData.emoji || "üëë")
      } else if (mentionData.action === "text") {
        await m.send(mentionData.text, { quoted: m })
      }
    }

    // Gestion r√©actions automatiques
    const areactData = await getData("areact_config") || {}
    if (areactData.global || areactData.activeChats?.includes(m.chat)) {
      const emojis = ["üëç", "‚ù§Ô∏è", "üî•", "üëè", "üéâ", "ü§©", "üí´", "‚ú®"]
      const emojiAleatoire = emojis[Math.floor(Math.random() * emojis.length)]
      await m.react(emojiAleatoire)
    }
  } catch (e) {
    console.error("‚ùå Erreur √©v√©nement:", e)
  }
})

// ==================== M√âTHODES D'AIDE ====================

GestionnaireCommandes.prototype.genererAidePermissions = function() {
  return `
üîì *SYST√àME DE PERMISSIONS*

üìã **Liste** 
\`.permit list\` - Voir les permissions

‚ûï **Ajouter**
\`.permit all\` - Toutes les commandes
\`.permit [type]\` - Par type (fun, tools, etc.)
\`.permit cmd [nom]\` - Commande sp√©cifique

‚ûñ **Retirer**  
\`.permit remove all\` - Tout supprimer
\`.permit remove [type]\` - Type sp√©cifique
\`.permit remove cmd [nom]\` - Commande sp√©cifique
  `.trim()
}

GestionnaireCommandes.prototype.afficherAideMention = async function(m) {
  await m.send(`
üëë *SYST√àME DE MENTION*

üîß **Options disponibles:**
\`.mention off\` - D√©sactiver
\`.mention status\` - Statut actuel  
\`.mention react üéØ\` - R√©agir aux mentions
\`.mention text [message]\` - R√©pondre aux mentions

üí° **Exemples:**
\`.mention react ‚ù§Ô∏è\`
\`.mention text Je suis occup√© !\`
  `.trim())
}

GestionnaireCommandes.prototype.afficherAideAreact = async function(m) {
  await m.send(`
ü§ñ *R√âACTIONS AUTOMATIQUES*

üîÑ **Commandes:**
\`.areact on\` - Activer pour ce chat
\`.areact on global\` - Activer partout
\`.areact off\` - D√©sactiver pour ce chat  
\`.areact off global\` - Tout d√©sactiver
\`.areact status\` - Voir le statut

‚ö° Le bot r√©agira al√©atoirement aux messages
  `.trim())
}

console.log("‚úÖ Module commandes tools charg√© avec succ√®s")
