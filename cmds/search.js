/* 
 * Copyright ¬© 2025 Mirage
 * Ce fichier fait partie de Kord et est sous licence GNU GPLv3.
 * Et j'esp√®re que vous savez ce que vous faites ici.
 * Vous ne pouvez pas utiliser ce fichier sauf en conformit√© avec la Licence.
 * Voir le fichier LICENSE ou https://www.gnu.org/licenses/gpl-3.0.html
 * -------------------------------------------------------------------------------
 */

const { King,
  wtype,
  npmstalk,
  duckduckgo,
  searchBing,
  audioCut,
  ytaudio,
  ytvideo,
  prefix,
  searchYahoo } = require("../core")
const gis = require('g-i-s')
const { promisify } = require('util')
const { v4: uuidv4 } = require('uuid')
const gisPromise = promisify(gis)
const FormData = require('form-data')
const fetch = require('node-fetch')
const crypto = require('crypto')
const yts = require("yt-search")
const ffmpeg = require('fluent-ffmpeg')
const fs = require('fs')

King(
{
        cmd: "websearch|search|recherche",
        desc: "rechercher sur le web bas√© sur une requ√™te",
        fromMe: wtype,
        react: "üîé",
        type: "search",
}, async (m, text) => {
        let q
        if (!text) { 
           q = m.quoted?.text
        } else {
        q = text
        }
        if (!q) return m.send("_*R√©pondez ou fournissez une requ√™te !*_")
         m.react("üîé")
         var res = await duckduckgo(q)
         if (!res.length) return m.send("_Aucun r√©sultat trouv√©_")
         const formatted = res.map((item, index) => {
  const fullLink = decodeURIComponent(item.link.split('uddg=')[1].split('&')[0])
  return `
‚ûî *R√©sultat ${index + 1}*
*‚ùñ Titre:* ${item.title}
*‚ûî Lien:* ${fullLink}
*¬∞ Description:* ${item.description}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
`
}).join('\n')
        m.react("‚úÖ")
        return m.send(formatted)
})


King({
        cmd: "img|image",
        desc: "rechercher des images bas√©es sur une requ√™te",
        fromMe: wtype,
        react: "üñºÔ∏è",
        type: "search",
}, async (m, text) => {
        let q = text || m.quoted?.text
        if (!q) return m.send("_*R√©pondez √† un message ou fournissez une requ√™te de recherche !*_")
        m.react("‚è≥")
        const opt = {
                searchTerm: q,
                queryStringAddition: '&safe=false',
                filterOutDomains: ['deviantart.com']
        }
        try {
                const imgs = await gisPromise(opt)
                if (!imgs || imgs.length === 0) return m.send("_D√©sol√©, je n'ai rien trouv√©..._")
                const selected = imgs.slice(0, 3)
                for (let img of selected) {
                        await m.send(img.url, {}, "image")
                }
        m.react("‚úÖ")
        } catch (err) {
                console.error(err)
                m.send("_√âchec de la r√©cup√©ration des images._")
        }
})

King({
        cmd: "npm",
        desc: "donne la description d'un package npm donn√©",
        fromMe: wtype,
        react: "üì¶",
        type: "search",
}, async (m, text) => {
        if (!text) return m.send(`_*Fournissez un package npm*_\n_Exemple: ${prefix}npm axios`)
        var n = await npmstalk(text)
        return m.send(`\`\`\`‚ùè INFORMATIONS PACKAGE NPM ‚ùè 
‚û• _*Nom:*_ ${n.name}
‚û• _*Derni√®re Version:*_ ${n.versionLatest}
‚û• _*Version Publi√©e:*_ ${n.versionPublish}
‚û• _*Heure de Publication:*_ ${n.publishTime}
‚û• _*Derni√®re Heure de Publication:*_ ${n.latestPublishTime}
‚û• _*D√©pendances R√©centes:*_ ${n.latestDependencies}\`\`\``)
})


function buildStringToSign(
    method,
    uri,
    accessKey,
    dataType,
    signatureVersion,
    timestamp
) {
    return [method, uri, accessKey, dataType, signatureVersion, timestamp].join(
        '\n'
    )
}
function sign(signString, accessSecret) {
    return crypto
        .createHmac('sha1', accessSecret)
        .update(Buffer.from(signString, 'utf-8'))
        .digest()
        .toString('base64')
}

King({
  cmd: "shazam|findaudio|find|identifyaudio|reconnaitre",
  desc: "rechercher les d√©tails audio d'une vid√©o/audio r√©pondu",
  fromMe: wtype,
  react: "üé∂",
  type: "search",
}, async (m, text) => {
  if (!(m.quoted.audio || m.quoted.video)) return await m.send("‚ù¶ *R√©pondez √† un message audio/vid√©o*")
  try {
    var media = await m.client.dlandsave(m.quoted)
    var opt = {
      host: 'identify-eu-west-1.acrcloud.com',
      endpoint: '/v1/identify',
      signature_version: '1',
      data_type: 'audio',
      secure: true,
      access_key: '8c21a32a02bf79a4a26cb0fa5c941e95',
      access_secret: 'NRSxpk6fKwEiVdNhyx5lR0DP8LzeflYpClNg1gze',
    }
    const daa = await audioCut(media, 0, 15)
    const data = daa.data
    const current_data = new Date()
    const timestamp = current_data.getTime() / 1000
    const stringToSign = buildStringToSign(
      'POST',
      opt.endpoint,
      opt.access_key,
      opt.data_type,
      opt.signature_version,
      timestamp
    )
    const signature = sign(stringToSign, opt.access_secret)
    const form = new FormData()
    form.append('sample', data)
    form.append('sample_bytes', data.length)
    form.append('access_key', opt.access_key)
    form.append('data_type', opt.data_type)
    form.append('signature_version', opt.signature_version)
    form.append('signature', signature)
    form.append('timestamp', timestamp)

    const res = await fetch('http://' + opt.host + opt.endpoint, {
      method: 'POST',
      body: form,
    })
    const { status, metadata } = await res.json()
    if (status.code === 0) {
      const track = metadata.music[0]
      let ytInfo = null
      try {
        const searchQuery = `${track.title} ${track.artists[0].name}`
        const ytResults = await yts(searchQuery)
        ytInfo = ytResults.videos[0]
      } catch (error) {
        console.error("Erreur recherche YouTube:", error)
      }
      const resultText = `_*Audio Trouv√© !*_\n\n` +
        `‚û§ *Titre*: ${track.title}\n` +
        `‚û§ *Artiste*: ${track.artists.map(a => a.name).join(", ")}\n` +
        `‚û§ *Album*: ${track.album.name}\n` +
        `‚û§ *Sorti le*: ${track.release_date || "N/A"}\n\n` +
        `*_√âcouter sur :_*\n` +
        `‚û§ *Spotify*: ${track.external_metadata.spotify?.track.id ? 
          `https://open.spotify.com/track/${track.external_metadata.spotify.track.id}` : "N/A"}\n` +
        `‚û§ *YouTube*: ${ytInfo ? ytInfo.url : 
          (track.external_metadata.youtube?.vid ? 
            `https://youtube.com/watch?v=${track.external_metadata.youtube.vid}` : "N/A")}\n\n` +
        (ytInfo ? `*Infos YouTube:*\n` +
          `‚û§ *Vues*: ${ytInfo.views.toLocaleString()}\n` +
          `‚û§ *Dur√©e*: ${ytInfo.duration.timestamp}\n` +
          `‚û§ *Upload√©*: ${ytInfo.ago}\n` : '') + 
          `_*R√âPONDEZ*_\n 1. audio\n 2. vid√©o\n_pour le t√©l√©charger !*_`
      
      const thumbnailUrl = ytInfo?.thumbnail || 
        (track.external_metadata.spotify?.album.id ? 
          `https://i.scdn.co/image/${track.external_metadata.spotify.album.id}` :
          "https://via.placeholder.com/300")
      var sMsg = await m.send(thumbnailUrl, { caption: resultText, quoted: m }, "image")
      
      try {
        var rMsg = await m.getResponse(sMsg, 60000)
        await sMsg.react("‚è∞")
        var rs = rMsg.text.toLowerCase()
        if (rs === "audio" || rs === "download" || rs === "1" || rs === "send" || rs === "envoyer") {
          if (!ytInfo || !ytInfo.url) {
            return await m.send("D√©sol√©, lien YouTube non disponible pour t√©l√©charger l'audio")
          }
          var mp3Link = await ytaudio(ytInfo.url)
          var mp = mp3Link.url
          await m.send(mp, { ptt: false, quoted: rMsg }, "audio")
          
        } else if (rs === "video" || rs === "vid√©o" || rs === "2") {
          if (!ytInfo || !ytInfo.url) {
            return await m.send("D√©sol√©, lien YouTube non disponible pour t√©l√©charger la vid√©o")
          }
          
          var mp4Link = await ytvideo(ytInfo.url)
          var mk = mp4Link.url
          await m.send(mk, { caption: `*Vid√©o pour ${ytInfo.title}*`, quoted: rMsg }, "video")
        } else {
          await m.send("Option invalide. Veuillez r√©pondre avec '1' pour audio ou '2' pour vid√©o.")
        }
      } catch (e) {
        console.error("Erreur gestion r√©ponse:", e)
        await sMsg.react("‚ùå")
      }
            
    } else {
      return await m.send("_Impossible de trouver cette chanson..._")
    }
    const filesToDelete = [media, daa.path]
    for (const file of filesToDelete) {
      if (fs.existsSync(file)) {
        fs.unlinkSync(file)
      }
    }
  } catch (error) {
    console.error(error)
    return await m.send(`Erreur: ${error.message || error}`)
  }
})

King({
  cmd: "element",
  desc: "obtenir les informations d'un √©l√©ment p√©riodique",
  fromMe: wtype,
  type: "tools",
}, async (m, text) => {
  try {
  if (!text) return await m.send(`*ùå´ Fournissez un nom d'√©l√©ment !*\n_exemple: ${prefix}element Hydrog√®ne`)
  const elementName = encodeURIComponent(text)
      var apiUrl = `https://api.popcat.xyz/periodic-table?element=${elementName}`
      var data = await m.axios(apiUrl)
            if (data.name) {
              const imageUrl = data.image
      const responseText = `
*‚ú† Nom de l'√©l√©ment:* ${data.name}
*‚ú† Symbole:* ${data.symbol}
*‚ú† Num√©ro atomique:* ${data.atomic_number}
*‚ú† Masse atomique:* ${data.atomic_mass}
*‚ú† P√©riode:* ${data.period}
*‚ú† Phase:* ${data.phase}
*‚ú† D√©couvert par:* ${data.discovered_by}

*‚ùç R√©sum√©:* ${data.summary}
`

      await m.send(imageUrl, { caption: responseText, quoted: m}, "image")
            } else {
              return await m.send("_rien trouv√©.._")
            }
} catch (e) {
    console.log("erreur commande", e)
    return await m.sendErr(e)
  }
})

// =============================================
// COMMANDES DE RECHERCHE SUPPL√âMENTAIRES POUR KING üëë
// =============================================

King({
  cmd: "youtube|yt",
  desc: "rechercher des vid√©os sur YouTube",
  fromMe: wtype,
  react: "üé•",
  type: "search",
}, async (m, text) => {
  try {
    let q = text || m.quoted?.text
    if (!q) return m.send("_*Fournissez une requ√™te de recherche YouTube !*_")
    
    m.react("‚è≥")
    const results = await yts(q)
    
    if (!results.videos.length) {
      m.react("‚ùå")
      return m.send("_Aucune vid√©o trouv√©e pour cette recherche_")
    }

    const topVideos = results.videos.slice(0, 5)
    let response = `*üîé R√âSULTATS YOUTUBE POUR:* ${q}\n\n`
    
    topVideos.forEach((video, index) => {
      response += `*${index + 1}. ${video.title}*\n`
      response += `üë§ ${video.author.name}\n`
      response += `‚è±Ô∏è ${video.duration.timestamp} | üëÅÔ∏è ${video.views.toLocaleString()} vues\n`
      response += `üìÖ ${video.ago}\n`
      response += `üîó ${video.url}\n\n`
    })

    response += `_R√©pondez avec le num√©ro pour t√©l√©charger la vid√©o_`
    
    m.react("‚úÖ")
    return m.send(response)
  } catch (err) {
    console.error(err)
    m.react("‚ùå")
    m.send("_√âchec de la recherche YouTube_")
  }
})

King({
  cmd: "urban|dictionnaire",
  desc: "rechercher une d√©finition sur Urban Dictionary",
  fromMe: wtype,
  react: "üìö",
  type: "search",
}, async (m, text) => {
  try {
    let q = text || m.quoted?.text
    if (!q) return m.send("_*Fournissez un terme √† rechercher !*_")
    
    m.react("‚è≥")
    const response = await m.axios(`https://api.urbandictionary.com/v0/define?term=${encodeURIComponent(q)}`)
    
    if (!response.list || response.list.length === 0) {
      m.react("‚ùå")
      return m.send("_Aucune d√©finition trouv√©e pour ce terme_")
    }

    const definition = response.list[0]
    const resultText = `
*üìñ URBAN DICTIONARY: ${q.toUpperCase()}*

*üìù D√©finition:*
${definition.definition}

*üí° Exemple:*
${definition.example}

*üëç ${definition.thumbs_up} | üëé ${definition.thumbs_down}*
*Auteur: ${definition.author}*
`

    m.react("‚úÖ")
    return m.send(resultText)
  } catch (err) {
    console.error(err)
    m.react("‚ùå")
    m.send("_√âchec de la recherche Urban Dictionary_")
  }
})

King({
  cmd: "wiki|wikipedia",
  desc: "rechercher sur Wikipedia",
  fromMe: wtype,
  react: "üåê",
  type: "search",
}, async (m, text) => {
  try {
    let q = text || m.quoted?.text
    if (!q) return m.send("_*Fournissez une requ√™te Wikipedia !*_")
    
    m.react("‚è≥")
    const response = await m.axios(`https://fr.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(q)}`)
    
    if (response.title && response.extract) {
      const resultText = `
*üåê WIKIPEDIA: ${response.title}*

${response.extract}

${response.thumbnail ? `*Image:* ${response.thumbnail.source}` : ''}
${response.content_urls ? `*Lien:* ${response.content_urls.desktop.page}` : ''}
`

      if (response.thumbnail) {
        m.react("‚úÖ")
        return await m.send(response.thumbnail.source, { caption: resultText }, "image")
      } else {
        m.react("‚úÖ")
        return m.send(resultText)
      }
    } else {
      m.react("‚ùå")
      return m.send("_Aucun article Wikipedia trouv√©_")
    }
  } catch (err) {
    console.error(err)
    m.react("‚ùå")
    m.send("_√âchec de la recherche Wikipedia_")
  }
})

King({
  cmd: "lyrics|paroles",
  desc: "trouver les paroles d'une chanson",
  fromMe: wtype,
  react: "üéµ",
  type: "search",
}, async (m, text) => {
  try {
    let q = text || m.quoted?.text
    if (!q) return m.send("_*Fournissez le titre d'une chanson !*_")
    
    m.react("‚è≥")
    const response = await m.axios(`https://api.lyrics.ovh/v1/${encodeURIComponent(q)}`)
    
    if (response.lyrics) {
      const lyrics = response.lyrics
      // Limiter la longueur pour √©viter les messages trop longs
      const truncatedLyrics = lyrics.length > 1500 ? lyrics.substring(0, 1500) + "...\n\n_[Paroles tronqu√©es - trop long]_" : lyrics
      
      const resultText = `
*üéµ PAROLES: ${q}*

${truncatedLyrics}
`
      m.react("‚úÖ")
      return m.send(resultText)
    } else {
      m.react("‚ùå")
      return m.send("_Paroles non trouv√©es pour cette chanson_")
    }
  } catch (err) {
    console.error(err)
    m.react("‚ùå")
    m.send("_√âchec de la recherche de paroles_")
  }
})

King({
  cmd: "news|actualites",
  desc: "obtenir les derni√®res actualit√©s",
  fromMe: wtype,
  react: "üì∞",
  type: "search",
}, async (m, text) => {
  try {
    m.react("‚è≥")
    const query = text ? `&q=${encodeURIComponent(text)}` : ''
    const response = await m.axios(`https://newsapi.org/v2/top-headlines?country=fr${query}&apiKey=your_api_key_here`)
    
    // Note: Vous devrez obtenir une cl√© API gratuite sur newsapi.org
    if (response.articles && response.articles.length > 0) {
      const articles = response.articles.slice(0, 5)
      let newsText = `*üì∞ DERNI√àRES ACTUALIT√âS${text ? ` POUR: ${text}` : ''}*\n\n`
      
      articles.forEach((article, index) => {
        newsText += `*${index + 1}. ${article.title}*\n`
        newsText += `üìù ${article.description || 'Pas de description'}\n`
        newsText += `üîó ${article.url}\n`
        newsText += `---\n\n`
      })
      
      m.react("‚úÖ")
      return m.send(newsText)
    } else {
      m.react("‚ùå")
      return m.send("_Aucune actualit√© trouv√©e_")
    }
  } catch (err) {
    console.error(err)
    m.react("‚ùå")
    m.send("_√âchec de la r√©cup√©ration des actualit√©s_")
  }
})

King({
  cmd: "movie|film",
  desc: "rechercher des informations sur un film",
  fromMe: wtype,
  react: "üé¨",
  type: "search",
}, async (m, text) => {
  try {
    let q = text || m.quoted?.text
    if (!q) return m.send("_*Fournissez le titre d'un film !*_")
    
    m.react("‚è≥")
    const response = await m.axios(`http://www.omdbapi.com/?t=${encodeURIComponent(q)}&apikey=your_omdb_api_key`)
    
    // Note: Vous devrez obtenir une cl√© API gratuite sur omdbapi.com
    if (response.Response === "True") {
      const movie = response
      const resultText = `
*üé¨ FILM: ${movie.Title}*

*üìÖ Ann√©e:* ${movie.Year}
*‚≠ê Note:* ${movie.imdbRating}/10
*‚è±Ô∏è Dur√©e:* ${movie.Runtime}
*üé≠ Genre:* ${movie.Genre}
*üé¨ R√©alisateur:* ${movie.Director}
*üé≠ Acteurs:* ${movie.Actors}

*üìñ Synopsis:*
${movie.Plot}

*üèÜ R√©compenses:*
${movie.Awards}
`
      if (movie.Poster && movie.Poster !== "N/A") {
        m.react("‚úÖ")
        return await m.send(movie.Poster, { caption: resultText }, "image")
      } else {
        m.react("‚úÖ")
        return m.send(resultText)
      }
    } else {
      m.react("‚ùå")
      return m.send("_Film non trouv√©_")
    }
  } catch (err) {
    console.error(err)
    m.react("‚ùå")
    m.send("_√âchec de la recherche du film_")
  }
})

console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë       KING SEARCH SYSTEM      ‚ïë
‚ïë         üîç ACTIVATED üîç       ‚ïë
‚ïë                               ‚ïë
‚ïë  üåê Recherche Web    üñºÔ∏è Images  ‚ïë
‚ïë  üé∂ Shazam Audio     üé• YouTube ‚ïë
‚ïë  üìö Dictionnaire    üåê Wikipedia ‚ïë
‚ïë  üéµ Paroles         üì∞ Actualit√©s ‚ïë
‚ïë  üé¨ Films           ‚öóÔ∏è  √âl√©ments  ‚ïë
‚ïë                               ‚ïë
‚ïë     üëë KING MODE: ON üëë      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`)
